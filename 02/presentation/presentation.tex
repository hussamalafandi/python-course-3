\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}

% Theme settings
\usetheme{metropolis}


% Define custom colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    % keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\title{Python 3 - Fortgeschrittene Konzepte und Anwendungen}
\subtitle{Fortgeschrittenes OOP in Python}
\author{Hussam Alafandi}
\date{\today}

\begin{document}

\frame{\titlepage}

\section{Einleitung}

\begin{frame}{\textbf{Willkommen und Rückblick}}
\textbf{Ziele für heute:}
\begin{itemize}
    \item Grundlagen der objektorientierten Programmierung (OOP) festigen.
    \item Fortgeschrittene Themen wie Kapselung, abstrakte Klassen und Methoden erlernen.
    \item OOP anwenden, um reale Probleme zu modellieren.
    \item Debugging und Testen von OOP-Code üben.
\end{itemize}

% \pause
% \begin{block}{Frage}
%     Was sind die Hauptvorteile der Verwendung von OOP in der Softwareentwicklung?
% \end{block}
\end{frame}

\section{Kapselung}

\begin{frame}{\textbf{Was ist Kapselung?}}
\textbf{Definition:}
\begin{itemize}
    \item Kapselung bedeutet, Daten und Methoden, die auf diese Daten zugreifen, in einer Einheit (Klasse) zu bündeln.
    \item Zugriff auf Daten durch private und öffentliche Attribute steuern.
\end{itemize}
\textbf{Schlüsselkonzepte:}
\begin{itemize}
    \item Öffentliche Attribute: Von außerhalb der Klasse zugänglich.
    \item Private Attribute: Von außerhalb der Klasse verborgen (Verwendung des Präfixes `\_\_`).
\end{itemize}
\textbf{Vorteile der Kapselung:}
\begin{itemize}
    \item Schutz der Datenintegrität.
    % \item Reduzierung von Abhängigkeiten.
    \item Erleichterung von Änderungen und Erweiterungen.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\textbf{Beispiel für Kapselung}}
\textbf{Codebeispiel:}
\begin{lstlisting}[language=Python]
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # Privates Attribut

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def get_balance(self):
        return self.__balance

account = BankAccount("Alice", 1000)
print(account.get_balance())  # Zugriff auf private Daten über Methode
\end{lstlisting}
\end{frame}

\begin{frame}{\textbf{Kapselung und Datenzugriff}}
    \textbf{Diskussion:}
    \begin{itemize}
        \item Warum ist der direkte Zugriff auf `\_\_balance` nicht erlaubt?
        \only<2->{
            \begin{itemize}
                \item In Python wird `\_\_balance` durch Namensmangling in `\_ClassName\_\_balance` umbenannt.  
                \item Dadurch wird verhindert, dass der Wert direkt von außerhalb der Klasse geändert wird.
            \end{itemize}
        }
    
        \item Wie kann dies zu sicherem Programmieren beitragen?
        \only<2->{
            \begin{itemize}
                \item Verhindert unkontrollierte Manipulation von sensiblen Daten.  
                \item Erzwingt den Zugriff über getter- und setter-Methoden, die zusätzliche Prüfungen ermöglichen.
            \end{itemize}
        }
    \end{itemize}
\end{frame}
    

\section{Abstrakte Klassen}

\begin{frame}{\textbf{Was sind abstrakte Klassen?}}
\textbf{Definition:}
\begin{itemize}
    \item Abstrakte Klassen dienen als Blaupausen für andere Klassen.
    \item Sie können nicht direkt instanziiert werden.
    \item Verwendung des `abc`-Moduls in Python.
\end{itemize}
\textbf{Warum abstrakte Klassen verwenden?}
\begin{itemize}
    \item Erzwingen die Implementierung bestimmter Methoden in Unterklassen.
    \item Stellen eine konsistente Schnittstelle über verschiedene Unterklassen sicher.
\end{itemize}
\textbf{Beispiele für den Einsatz:}
\begin{itemize}
    \item Formen wie Rechtecke und Kreise.
    \item Fahrzeugtypen wie Autos und Motorräder.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\textbf{Beispiel für abstrakte Klassen}}
\textbf{Codebeispiel:}
\begin{lstlisting}[language=Python]
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Beispiel für abstrakte Klassen - 2}
\textbf{Codebeispiel:}
\begin{lstlisting}[language=Python]
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)
\end{lstlisting}
\textbf{Übung:}
\begin{itemize}
    \item Implementieren Sie eine `Circle`-Klasse, die von `Shape` erbt.
    \item Fügen Sie die Methoden `area` und `perimeter` hinzu.
\end{itemize}
\end{frame}

\section{Statische und Klassenmethoden}

\begin{frame}{\textbf{Statische und Klassenmethoden}}
\textbf{Definitionen:}
\begin{itemize}
    \item \textbf{Statische Methoden:} Definiert mit `@staticmethod`. Sie hängen nicht von Instanz- oder Klassenvariablen ab.
    \item \textbf{Klassenmethoden:} Definiert mit `@classmethod`. Sie nehmen die Klasse als ersten Parameter.
\end{itemize}
\textbf{Anwendungsfälle:}
\begin{itemize}
    \item Statische Methoden für Hilfsfunktionen (z.B. Berechnungen).
    \item Klassenmethoden für Factory-Methoden.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\textbf{Beispiel für statische und Klassenmethoden}}
\textbf{Codebeispiel:}
\begin{lstlisting}[language=Python]
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

    @classmethod
    def pi(cls):
        return 3.14159

print(MathUtils.add(5, 7))  # 12
print(MathUtils.pi())      # 3.14159
\end{lstlisting}
\end{frame}

\begin{frame}{Statische VS. Klassenmethoden}
    \textbf{Diskussion:}
    \begin{itemize}
        \item Wann sollte eine statische Methode anstelle einer Instanzmethode verwendet werden?
        \only<2->{ % Answer appears in slide step 2
            \begin{itemize}
                \item Statische Methoden sind sinnvoll, wenn die Methode keine Instanz- oder Klassenvariablen benötigt.
            \end{itemize}
        }
        
        \item Wie unterscheiden sich Klassenmethoden von statischen Methoden?
        \only<2->{ % Answer appears in slide step 3
            \begin{itemize}
                \item Klassenmethoden erhalten automatisch die Klassenreferenz `cls` und können Klassenvariablen verändern.
            \end{itemize}
        }
    \end{itemize}
\end{frame}

\section{Fazit}

\begin{frame}{\textbf{Zusammenfassung und Q\&A}}
\textbf{Wichtige Erkenntnisse:}
\begin{itemize}
    \item Kapselung schützt Daten innerhalb einer Klasse.
    \item Abstrakte Klassen bieten eine Blaupause für konsistente Schnittstellen.
    \item Statische und Klassenmethoden ermöglichen Dienstprogramme und klassenbezogene Verhaltensweisen.
    \item OOP hilft effektiv bei der Modellierung realer Probleme.
\end{itemize}
\textbf{Nächste Schritte:}
\begin{itemize}
    \item Modellierung realer Probleme üben.
    \item Heutige Codebeispiele überprüfen und erweitern.
    \item Experimentieren Sie mit abstrakten Klassen und Methoden.
\end{itemize}
\end{frame}

\end{document}
