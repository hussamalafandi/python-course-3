\documentclass[aspectratio=169]{beamer}
\usetheme{metropolis}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{adjustbox}

% --- TikZ (Flowcharts) ---
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning}

% Define custom colors for listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% --- TikZ styles for flowcharts ---
\tikzstyle{startstop} = [ellipse, draw, minimum width=2.6cm, minimum height=0.85cm, align=center]
\tikzstyle{process}   = [rectangle, draw, minimum width=3.6cm, minimum height=0.85cm, align=center]
\tikzstyle{decision}  = [diamond, draw, aspect=2.2, inner sep=1pt, align=center]
\tikzstyle{arrow}     = [-{Stealth[length=2.2mm]}, thick]

% Auto-fit TikZ diagrams to the available frame area (keeps aspect ratio)
\newenvironment{FitTikZ}[1][]%
{%
  \begin{adjustbox}{max totalsize={\textwidth}{0.78\textheight},center}%
  \begin{tikzpicture}[#1]%
}%
{%
  \end{tikzpicture}%
  \end{adjustbox}%
}

\title{Python 3 - Grundlagen und Ökosystem}
\subtitle{Unit 6: Mini Project I -- Expense Tracker \& Reporting (CLI)}
\author{Hussam Alafandi}
\date{\today}

\begin{document}

\maketitle

% =========================================================
% Overview
% =========================================================
\section{Unit 6: Überblick}

\begin{frame}{Ziel der Unit}
  \begin{itemize}
    \item Konsolidierung der Grundlagen aus Units 1--5 in einem realistischen Mini-Projekt.
    \item Fokus: \textbf{saubere Struktur}, \textbf{logischer Flow}, \textbf{Lesbarkeit}, \textbf{Korrektheit}.
    \item Ergebnis: Ein kleines CLI-Tool, das später leicht in OOP und Data Analysis erweitert werden kann.
  \end{itemize}
\end{frame}

\begin{frame}{Warum ein Expense Tracker?}
  \begin{itemize}
    \item Nutzt alle bisherigen Themen:
      \begin{itemize}
        \item Variablen/Typen, I/O, Debugging
        \item Kontrollfluss, Schleifen, Validierung
        \item Datenstrukturen: List/Dict/Set
        \item Funktionen, Module, Imports (Multi-File)
      \end{itemize}
    \item Bereitet sehr gut vor auf:
      \begin{itemize}
        \item Unit 7--8 (OOP-Refactor: Transaction/Ledger/Report)
        \item Unit 10--12 (CSV $\rightarrow$ Pandas $\rightarrow$ Visualisierung)
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Agenda}
  \begin{enumerate}
    \item Projektbrief (Scope \& Anforderungen)
    \item Datenmodell (ohne externe Libraries)
    \item Architektur \& Modulstruktur (Multi-File)
    \item Flowchart: Programmlogik
    \item Milestones (MVP $\rightarrow$ Erweiterungen)
    \item Abgabe \& Bewertungskriterien
  \end{enumerate}
\end{frame}

% =========================================================
% Project Brief
% =========================================================
\section{Projektbrief}

\begin{frame}{Projekt: Expense Tracker (CLI)}
  \textbf{Beschreibung:}\\
  Ein textbasiertes Programm zur Erfassung von Einnahmen/Ausgaben inkl. Reporting.\\[6pt]
  \textbf{Kernfeatures (MVP):}
  \begin{itemize}
    \item Transaktionen hinzufügen (Income/Expense)
    \item Transaktionen anzeigen (optional: Filter)
    \item Summary Report (Totals, Balance, pro Kategorie)
    \item Speichern/Laden (CSV oder JSON)
    \item Input-Validierung (robust, keine Crashes)
  \end{itemize}
\end{frame}

\begin{frame}{Nicht-Ziele (bewusst weggelassen)}
  \begin{itemize}
    \item Keine GUI, keine Web-App
    \item Keine Datenbank (nur CSV/JSON)
    \item Keine externen Libraries (nur Standard Library)
    \item Kein perfektes Datums-Parsing (nur einfache Formatprüfung)
  \end{itemize}
\end{frame}

% =========================================================
% Data Model
% =========================================================
\section{Datenmodell}

\begin{frame}[fragile]{Datenmodell: Transaction als Dictionary}
  \begin{itemize}
    \item Eine Transaktion wird als Dictionary gespeichert.
    \item Ein Ledger ist eine Liste von Transaktionen.
  \end{itemize}

\begin{lstlisting}[language=Python]
transaction = {
  "date": "2026-01-15",
  "type": "expense",          # "income" oder "expense"
  "category": "food",
  "amount": 12.50,
  "note": "lunch"
}

ledger = [transaction1, transaction2, ...]
\end{lstlisting}
\end{frame}

\begin{frame}{Warum dieses Datenmodell?}
  \begin{itemize}
    \item \textbf{List} = Reihenfolge + einfache Iteration (Reports, Filter).
    \item \textbf{Dict} = strukturiertes Objekt mit klaren Keys.
    \item \textbf{Set} = Hilfsstruktur (z.\,B. Kategorien ohne Duplikate).
    \item Später leicht umzustellen auf OOP (Transaction/Ledger Klassen).
  \end{itemize}
\end{frame}

% =========================================================
% Architecture / Modules
% =========================================================
\section{Architektur \& Module}

\begin{frame}[fragile]{Empfohlene Projektstruktur}
\begin{lstlisting}[language=bash]
expense_tracker/
  main.py
  utils.py
  logic.py
  reports.py
  storage.py
  data/
    ledger.csv
\end{lstlisting}
  \begin{itemize}
    \item \texttt{main.py}: Menu Loop / Program Entry
    \item \texttt{utils.py}: Input-Helper (read\_float, read\_choice, read\_date)
    \item \texttt{logic.py}: CRUD-Operationen auf Ledger
    \item \texttt{reports.py}: Aggregation/Reporting
    \item \texttt{storage.py}: Load/Save (CSV/JSON)
  \end{itemize}
\end{frame}

\begin{frame}{Designregel: I/O vs. Logik trennen}
  \begin{itemize}
    \item \textbf{I/O (input/print)} gehört in \texttt{main.py} und \texttt{utils.py}.
    \item \textbf{Logik} (berechnen/filtern/aggregieren) als Funktionen, die Werte \textbf{zurückgeben}.
    \item Vorteil:
      \begin{itemize}
        \item einfacher zu testen (Unit 14)
        \item leichter zu refactoren (OOP)
        \item weniger ``Spaghetti-Code''
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiel: Utility-Funktion (Input-Validierung)}
\begin{lstlisting}[language=Python]
def read_float(prompt, *, min_value=None):
    while True:
        text = input(prompt).strip()
        try:
            x = float(text)
        except ValueError:
            print("Bitte eine Zahl eingeben.")
            continue

        if min_value is not None and x < min_value:
            print(f"Wert muss >= {min_value} sein.")
            continue

        return x
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Beispiel: Logik-Funktion (kein print)}
  \begin{itemize}
    \item Logik-Funktionen sollen möglichst \textbf{deterministisch} und \textbf{side-effect-arm} sein.
  \end{itemize}
\begin{lstlisting}[language=Python]
def add_transaction(ledger, tx):
    # tx ist ein dict mit keys: date,type,category,amount,note
    ledger.append(tx)
    return ledger
\end{lstlisting}
\end{frame}

% =========================================================
% Flowchart: Menu Loop
% =========================================================
\section{Flowchart: Programmlogik}

\begin{frame}{Flowchart: Menü-gesteuerter Ablauf (High Level)}
  \centering
  \begin{FitTikZ}[node distance=0.95cm]
    \node (start) [startstop] {Start};
    \node (load)  [process, below=of start] {Lade Ledger (CSV/JSON)};
    \node (menu)  [process, below=of load] {Zeige Menü};
    \node (choice)[decision, below=of menu, yshift=-0.2cm] {Option?};

    \node (add)   [process, right=2.9cm of choice] {Add Transaction};
    \node (list)  [process, left=2.9cm of choice] {List / Filter};
    \node (rep)   [process, below=of choice, yshift=-0.2cm] {Report (Summary)};
    \node (save)  [process, below=of rep] {Save Ledger};
    \node (quit)  [startstop, below=of save] {Ende};

    \draw [arrow] (start) -- (load);
    \draw [arrow] (load) -- (menu);
    \draw [arrow] (menu) -- (choice);

    \draw [arrow] (choice) -- node[above]{1} (add);
    \draw [arrow] (add.east) -- ++(0.7,0) |- (menu.east);

    \draw [arrow] (choice) -- node[above]{2} (list);
    \draw [arrow] (list.west) -- ++(-0.7,0) |- (menu.west);

    \draw [arrow] (choice) -- node[left]{3} (rep);
    \draw [arrow] (rep) -- (save);

    \draw [arrow] (save) -- node[left]{4} (quit);

    % "Invalid" loop
    \draw [arrow] (choice.south east) -- ++(1.2,-0.8) node[right]{invalid} |- (menu.east);
  \end{FitTikZ}
\end{frame}

\begin{frame}{Mapping: Flowchart $\rightarrow$ Python-Konstrukte}
  \begin{itemize}
    \item Menü-Schleife: \texttt{while True:}
    \item Auswahl: \texttt{if/elif/else}
    \item Wiederholung bei invalid input: \texttt{continue}
    \item Exit: \texttt{break}
    \item Laden/Speichern: Standard Library (\texttt{csv} oder \texttt{json})
  \end{itemize}
\end{frame}

% =========================================================
% Persistence
% =========================================================
\section{Persistenz (CSV/JSON)}

\begin{frame}[fragile]{CSV-Format (empfohlen für späteres Pandas)}
  \begin{itemize}
    \item Spalten: \texttt{date,type,category,amount,note}
    \item Vorteil: später direkt \texttt{pd.read\_csv(...)} in Unit 11.
  \end{itemize}

\begin{lstlisting}[language=bash]
date,type,category,amount,note
2026-01-15,expense,food,12.50,lunch
2026-01-15,income,salary,2500.00,January
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Speichern mit \texttt{csv.DictWriter} (Skizze)}
\begin{lstlisting}[language=Python]
import csv

FIELDS = ["date", "type", "category", "amount", "note"]

def save_csv(path, ledger):
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=FIELDS)
        w.writeheader()
        for tx in ledger:
            w.writerow(tx)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Laden mit \texttt{csv.DictReader} (Skizze)}
\begin{lstlisting}[language=Python]
import csv

def load_csv(path):
    ledger = []
    try:
        with open(path, newline="", encoding="utf-8") as f:
            r = csv.DictReader(f)
            for row in r:
                row["amount"] = float(row["amount"])  # type conversion!
                ledger.append(row)
    except FileNotFoundError:
        pass  # Start with empty ledger
    return ledger
\end{lstlisting}
\end{frame}

% =========================================================
% Milestones
% =========================================================
\section{Milestones}

\begin{frame}{Milestone 1: MVP (In-Memory)}
  \begin{itemize}
    \item Menü + Ledger in Memory
    \item Add Transaction (mit Validierung)
    \item List Transactions
    \item Mindestens 3 Testfälle (manuell)
  \end{itemize}
\end{frame}

\begin{frame}{Milestone 2: Reporting}
  \begin{itemize}
    \item Summary:
      \begin{itemize}
        \item Total Income
        \item Total Expenses
        \item Balance
        \item Spend by Category
      \end{itemize}
    \item Implementiere Aggregationen ohne Pandas:
      \begin{itemize}
        \item Dictionary-Akkumulatoren
        \item Loop + if + \texttt{dict.get()}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Milestone 3: Persistenz}
  \begin{itemize}
    \item Save/Load (CSV oder JSON)
    \item Programmstart lädt vorhandene Daten
    \item Programmende speichert den aktuellen Stand
    \item Keine Datenverluste, robuste Fehlerbehandlung
  \end{itemize}
\end{frame}

\begin{frame}{Milestone 4 (Optional): Erweiterungen}
  \begin{itemize}
    \item Sortierung nach Datum oder Betrag
    \item Filter:
      \begin{itemize}
        \item nach Kategorie
        \item nach Typ (income/expense)
        \item nach Textsuche im Note
      \end{itemize}
    \item Monatsreport (grouping nach \texttt{YYYY-MM})
    \item Export: ``Report.txt'' (einfacher Textreport)
  \end{itemize}
\end{frame}

% =========================================================
% Deliverables & Rubric
% =========================================================
\section{Abgabe \& Bewertung}

\begin{frame}{Abgabe (Deliverables)}
  \begin{itemize}
    \item Projektordner inkl. \texttt{main.py} und Modulen
    \item Datendatei (\texttt{data/ledger.csv} oder \texttt{data/ledger.json})
    \item Kurze README:
      \begin{itemize}
        \item Setup (venv/conda + requirements)
        \item Starten des Programms
        \item Welche Features sind implementiert?
      \end{itemize}
    \item Optional: Demo-Screenshot oder Beispielausgabe
  \end{itemize}
\end{frame}

\begin{frame}{Bewertungskriterien (Rubrik)}
  \begin{itemize}
    \item \textbf{Correctness:} Ergebnisse stimmen, Daten werden korrekt gespeichert/geladen
    \item \textbf{Robustness:} Input-Validierung, keine Crashes bei falscher Eingabe
    \item \textbf{Structure:} Funktionen, Module, klare Verantwortlichkeiten
    \item \textbf{Readability:} gute Namen, konsistenter Stil, sinnvolle Kommentare/Docstrings
    \item \textbf{Data handling:} passende Nutzung von List/Dict/Set, saubere Aggregationen
  \end{itemize}
\end{frame}

\begin{frame}{Was wir später damit machen (Preview)}
  \begin{itemize}
    \item Unit 7--8: OOP-Refactor (Transaction, Ledger, Report als Klassen)
    \item Unit 9: Suchen/Sortieren (Algorithmen) auf dem Ledger
    \item Unit 11: CSV in Pandas laden und gruppieren
    \item Unit 12: Spend-by-Category als Bar Chart, Balance als Line Chart
  \end{itemize}
\end{frame}

\begin{frame}[standout]
  \huge Fragen?
\end{frame}

\end{document}
