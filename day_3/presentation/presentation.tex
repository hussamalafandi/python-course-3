\documentclass{beamer}
\usetheme{metropolis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

% Farbdefinitionen für Code-Highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{Fortgeschrittene OOP-Konzepte in Python}
\subtitle{Effektive Nutzung fortgeschrittener Python-Konzepte in der Praxis}
\author{Hussam Alafandi}
\date{\today}

\begin{document}

\maketitle

\begin{frame}{Agenda}
    \tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dunder-Methoden und Operatorüberladung}

\begin{frame}{Theorie: Dunder-Methoden}
    \begin{itemize}
        \item Dunder-Methoden sind spezielle Methoden, deren Name mit und endet mit \texttt{\_\_}.
        \item Sie ermöglichen die Integration eigener Klassen in die Python-Syntax.
        \item Beispiele: \texttt{\_\_init\_\_} (Konstruktor), \texttt{\_\_str\_\_} (String-Darstellung), \texttt{\_\_add\_\_} (Operatorüberladung).
    \end{itemize}
    \vspace{1em}
    \alert{Hinweis:} Detaillierte Beispiele und Übungen findest du im Notebook.
\end{frame}

\begin{frame}[fragile]{Kurzes Beispiel: Person-Klasse}
    \begin{lstlisting}[language=Python]
class Person:
    def __init__(self, name, alter):
        self.name = name
        self.alter = alter

    def __str__(self):
        return f"{self.name}, {self.alter} Jahre alt"

p = Person("Anna", 30)
print(p)
    \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Komposition vs. Vererbung}

\begin{frame}{Theorie: Vererbung \& Komposition}
    \begin{itemize}
        \item \textbf{Vererbung:} Erlaubt es, eine neue Klasse auf Basis einer bestehenden zu erstellen.\\
              \emph{Vorteil:} Wiederverwendung von Code.\\
              \emph{Nachteil:} Kann zu starker Kopplung führen.
        \item \textbf{Komposition:} Eine Klasse verwendet andere Klassen als Attribute.\\
              \emph{Vorteil:} Flexibles, lose gekoppeltes Design.
    \end{itemize}
    \vspace{1em}
    \alert{Weitere Details und Beispiele im Notebook.}
\end{frame}

\begin{frame}[fragile]{Kurzes Beispiel: Fahrzeug und Auto}
    Beispiel für Vererbung:
    \begin{lstlisting}[language=Python]
class Fahrzeug:
    def starten(self):
        print("Fahrzeug startet")

class Auto(Fahrzeug):
    pass

a = Auto()
a.starten()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Kurzes Beispiel: Fahrzeug und Auto}
    Beispiel für Komposition:
    \begin{lstlisting}[language=Python]
class Motor:
    def starten(self):
        print("Motor startet")

class AutoMitMotor:
    def __init__(self):
        self.motor = Motor()
    def starten(self):
        self.motor.starten()
    \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphismus \& Duck Typing}

\begin{frame}{Theorie: Polymorphismus und Duck Typing}
    \begin{itemize}
        \item \textbf{Polymorphismus:} Unterschiedliche Objekte reagieren auf denselben Methodenaufruf.
        \item \textbf{Duck Typing:} Es zählt, ob ein Objekt die benötigte Methode besitzt – nicht dessen Typ.
    \end{itemize}
    \vspace{1em}
    \alert{Details und praktische Beispiele gibt es im Notebook.}
\end{frame}

\begin{frame}[fragile]{Kurzes Beispiel: Duck Typing}
    \begin{lstlisting}[language=Python]
def starte_fahrzeug(fahrzeug):
    fahrzeug.fahre()

class Auto:
    def fahre(self):
        print("Auto fährt")

class Fahrrad:
    def fahre(self):
        print("Fahrrad fährt")

starte_fahrzeug(Auto())
starte_fahrzeug(Fahrrad())
    \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Entwurfsmuster (Design Patterns)}

\begin{frame}{Theorie: Entwurfsmuster}
    \begin{itemize}
        \item Entwurfsmuster sind wiederverwendbare Lösungen für häufige Design-Probleme.
        \item In Python helfen sie, den Code wartbar und erweiterbar zu gestalten.
        \item Wichtige Muster: Singleton, Factory, Observer, Strategy.
    \end{itemize}
    \vspace{1em}
    \alert{Ausführliche Erklärungen, Codebeispiele und Übungen im Notebook.}
\end{frame}

\begin{frame}[fragile]{Kurzes Beispiel: Singleton}
    \begin{lstlisting}[language=Python]
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  % Ausgabe: True
    \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zusammenfassung und Ausblick}

\begin{frame}{Zusammenfassung}
    \begin{itemize}
        \item \textbf{Dunder-Methoden:} Integrieren eigene Klassen in die Python-Syntax.
        \item \textbf{Komposition vs. Vererbung:} Komposition bietet flexible, lose gekoppelte Designs.
        \item \textbf{Polymorphismus \& Duck Typing:} Erlauben generischen Code, der auf den Fähigkeiten der Objekte basiert.
        \item \textbf{Entwurfsmuster:} Bieten Lösungen für wiederkehrende Probleme.
    \end{itemize}
\end{frame}

\begin{frame}{Fragen \& Diskussion}
    \centering
    \Large Vielen Dank für Ihre Aufmerksamkeit!
\end{frame}

\end{document}
