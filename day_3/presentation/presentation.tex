\documentclass{beamer}
\usetheme{metropolis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

% Farbdefinitionen für Code-Highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\title{Fortgeschrittene OOP-Konzepte in Python}
\subtitle{Dunder-Methoden, Operator Overloading, Komposition vs. Vererbung, Polymorphismus, Duck Typing und Design Patterns}
\author{Ihr Name}
\date{\today}

\begin{document}

\maketitle

% Agenda
\begin{frame}{Agenda}
    \tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dunder-Methoden und Operator Overloading}

\begin{frame}{Einführung in Dunder-Methoden}
    \begin{itemize}
        \item \textbf{Dunder-Methoden} (Double Underscore) sind spezielle Methoden in Python, deren Namen mit \texttt{\_\_} beginnen und enden.
        \item Beispiele: \texttt{\_\_init\_\_}, \texttt{\_\_str\_\_}, \texttt{\_\_repr\_\_}, \texttt{\_\_add\_\_}, \texttt{\_\_len\_\_} usw.
        \item Sie erlauben es, benutzerdefinierte Klassen in Python nahtlos in Sprachkonstrukte zu integrieren.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiel: \texttt{\_\_init\_\_} und \texttt{\_\_str\_\_}}
    \begin{lstlisting}[language=Python]
class Person:
    def __init__(self, name, alter):
        self.name = name
        self.alter = alter

    def __str__(self):
        return f"{self.name}, {self.alter} Jahre alt"

p = Person("Anna", 30)
print(p)  # Ausgabe: Anna, 30 Jahre alt
    \end{lstlisting}
\end{frame}

\begin{frame}{Operator Overloading: Grundlagen}
    \begin{itemize}
        \item Operator Overloading erlaubt es, Standardoperatoren (z.B. \texttt{+}, \texttt{-}, \texttt{*}) mit eigenen Klassen zu verwenden.
        \item Python löst z.B. bei \texttt{obj1 + obj2} automatisch die Methode \texttt{\_\_add\_\_} auf.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiel: Vektor-Klasse mit Operator Overloading}
    \begin{lstlisting}[language=Python]
class Vektor:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vektor(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"Vektor({self.x}, {self.y})"

v1 = Vektor(2, 3)
v2 = Vektor(4, 5)
v3 = v1 + v2
print(v3)  # Ausgabe: Vektor(6, 8)
    \end{lstlisting}
\end{frame}

\begin{frame}{Weitere nützliche Dunder-Methoden}
    \begin{itemize}
        \item \texttt{\_\_eq\_\_}: Vergleicht Objekte (z.B. \texttt{==})
        \item \texttt{\_\_len\_\_}: Ermöglicht die Verwendung von \texttt{len(obj)}
        \item \texttt{\_\_getitem\_\_} und \texttt{\_\_setitem\_\_}: Erlauben Indexzugriffe
        \item \texttt{\_\_iter\_\_}: Ermöglicht Iteration über das Objekt
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Komposition vs. Vererbung (Favor Composition)}

\begin{frame}[fragile]{Vererbung: Grundlagen}
    \begin{itemize}
        \item Vererbung erlaubt es, eine neue Klasse basierend auf einer bestehenden zu definieren.
        \item Ermöglicht Code-Wiederverwendung, kann jedoch zu starker Kopplung führen.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Fahrzeug:
    def starten(self):
        print("Fahrzeug startet")

class Auto(Fahrzeug):
    pass

a = Auto()
a.starten()  # Ausgabe: Fahrzeug startet
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Komposition: Grundlagen}
    \begin{itemize}
        \item Bei der Komposition enthält ein Objekt andere Objekte als Attribute.
        \item Dies führt zu lose gekoppelten und flexibleren Designs.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Motor:
    def starten(self):
        print("Motor startet")

class Auto:
    def __init__(self):
        self.motor = Motor()

    def starten(self):
        self.motor.starten()

a = Auto()
a.starten()  # Ausgabe: Motor startet
    \end{lstlisting}
\end{frame}

\begin{frame}{Warum Komposition bevorzugen?}
    \begin{itemize}
        \item \textbf{Wiederverwendbarkeit:} Einzelne Komponenten können in verschiedenen Kontexten genutzt werden.
        \item \textbf{Flexibilität:} Leichtere Anpassung und Austausch von Komponenten.
        \item \textbf{Vermeidung von tiefen Vererbungsstrukturen:} Erhöht die Wartbarkeit.
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphismus \& Duck Typing in Python}

\begin{frame}{Polymorphismus: Prinzipien}
    \begin{itemize}
        \item Erlaubt es, dass unterschiedliche Objekte auf denselben Methodenaufruf reagieren.
        \item Führt zu generischem Code, der mit verschiedenen Objekttypen arbeitet.
    \end{itemize}
\end{frame}

\begin{frame}{Duck Typing: Das Prinzip}
    \begin{itemize}
        \item „Wenn es aussieht wie eine Ente und quakt wie eine Ente, dann ist es eine Ente.“
        \item Python überprüft nicht den Typ, sondern ob das Objekt die benötigte Methode besitzt.
        \item Keine Notwendigkeit, explizit Schnittstellen zu implementieren.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiel: Duck Typing in Aktion}
    \begin{lstlisting}[language=Python]
class Ente:
    def quaken(self):
        print("Quak, quak!")

class Hund:
    def quaken(self):
        print("Ich kann nicht quaken, aber ich belle!")

def tier_macht_geraeusch(tier):
    tier.quaken()

ente = Ente()
hund = Hund()
tier_macht_geraeusch(ente)  # Ausgabe: Quak, quak!
tier_macht_geraeusch(hund)  # Ausgabe: Ich kann nicht quaken, aber ich belle!
    \end{lstlisting}
\end{frame}

\begin{frame}{Vorteile von Polymorphismus und Duck Typing}
    \begin{itemize}
        \item \textbf{Flexibilität:} Funktionen und Methoden können mit verschiedenen Objekttypen arbeiten.
        \item \textbf{Einfachheit:} Reduzierung von starren Typüberprüfungen.
        \item \textbf{Ermöglicht generische Programmierung:} Bessere Wiederverwendbarkeit des Codes.
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design Patterns (Nur wesentliche)}

\begin{frame}{Einführung in Design Patterns}
    \begin{itemize}
        \item Design Patterns sind bewährte Lösungen für wiederkehrende Probleme im Software-Design.
        \item Sie helfen dabei, den Code verständlicher und wartbarer zu gestalten.
        \item In Python sind nicht alle Patterns zwingend notwendig – Fokus auf wesentliche.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Singleton Pattern}
    \begin{itemize}
        \item \textbf{Ziel:} Sicherstellen, dass von einer Klasse nur eine einzige Instanz existiert.
        \item Nützlich, wenn ein globaler Zugriffspunkt benötigt wird.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

# Test
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # Ausgabe: True
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Factory Pattern}
    \begin{itemize}
        \item \textbf{Ziel:} Erstellung von Objekten, ohne deren konkrete Klassen zu spezifizieren.
        \item Bietet Flexibilität bei der Objekterzeugung.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Tier:
    def sprich(self):
        pass

class Katze(Tier):
    def sprich(self):
        print("Miau")

class Hund(Tier):
    def sprich(self):
        print("Wuff")

class TierFactory:
    @staticmethod
    def erstelle_tier(tier_typ):
        if tier_typ == "Katze":
            return Katze()
        elif tier_typ == "Hund":
            return Hund()
        else:
            raise ValueError("Unbekannter Tier-Typ")

# Test
tier = TierFactory.erstelle_tier("Katze")
tier.sprich()  # Ausgabe: Miau
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Observer Pattern}
    \begin{itemize}
        \item \textbf{Ziel:} Ermöglicht es, dass ein Objekt (Subject) mehrere andere Objekte (Observer) über Zustandsänderungen informiert.
        \item Besonders nützlich in ereignisgesteuerten Anwendungen.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Observable:
    def __init__(self):
        self.beobachter = []

    def registriere_beobachter(self, beobachter):
        self.beobachter.append(beobachter)

    def benachrichtige_beobachter(self, nachricht):
        for b in self.beobachter:
            b.update(nachricht)

class Beobachter:
    def update(self, nachricht):
        print(f"Beobachter erhielt: {nachricht}")

# Test
observable = Observable()
beobachter = Beobachter()
observable.registriere_beobachter(beobachter)
observable.benachrichtige_beobachter("Daten aktualisiert")
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Strategy Pattern (optional)}
    \begin{itemize}
        \item \textbf{Ziel:} Auswahl eines Algorithmus zur Laufzeit.
        \item Trennt den Algorithmus von der Anwendungslogik.
    \end{itemize}
    \begin{lstlisting}[language=Python]
class Strategie:
    def berechne(self, a, b):
        pass

class Addition(Strategie):
    def berechne(self, a, b):
        return a + b

class Multiplikation(Strategie):
    def berechne(self, a, b):
        return a * b

class Kontext:
    def __init__(self, strategie):
        self.strategie = strategie

    def ausfuehren(self, a, b):
        return self.strategie.berechne(a, b)

# Test
kontext = Kontext(Addition())
print(kontext.ausfuehren(3, 4))  # Ausgabe: 7
kontext.strategie = Multiplikation()
print(kontext.ausfuehren(3, 4))  # Ausgabe: 12
    \end{lstlisting}
\end{frame}

\begin{frame}{Wichtige Hinweise zu Design Patterns in Python}
    \begin{itemize}
        \item Aufgrund der dynamischen Natur von Python sind manche Patterns weniger zwingend.
        \item Nutzen Sie Patterns als \textbf{Richtlinien} – nicht als starre Regeln.
        \item Wesentlich ist das Verständnis des zugrunde liegenden Problems.
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zusammenfassung und Ausblick}

\begin{frame}{Zusammenfassung}
    \begin{itemize}
        \item \textbf{Dunder-Methoden:} Erlauben die Integration von benutzerdefinierten Klassen in die Python-Syntax.
        \item \textbf{Operator Overloading:} Macht den Einsatz von Operatoren bei eigenen Klassen intuitiver.
        \item \textbf{Komposition vs. Vererbung:} Komposition bietet oft flexiblere und weniger gekoppelte Designs.
        \item \textbf{Polymorphismus \& Duck Typing:} Fördern generischen, dynamischen Code, der sich auf die Methodenfähigkeit eines Objekts konzentriert.
        \item \textbf{Design Patterns:} Bieten bewährte Lösungen für wiederkehrende Probleme – in Python pragmatisch einsetzen.
    \end{itemize}
\end{frame}

\begin{frame}{Weiterführende Literatur und Ressourcen}
    \begin{itemize}
        \item \textbf{Bücher:} \emph{Fluent Python} von Luciano Ramalho
        \item \textbf{Online-Ressourcen:} Python-Dokumentation, Blogs zu Design Patterns in Python
        \item \textbf{Übungen:} Praktische Projekte und kleine Übungen, um die Konzepte zu festigen
    \end{itemize}
\end{frame}

\begin{frame}{Fragen \& Diskussion}
    \centering
    \Large Vielen Dank für Ihre Aufmerksamkeit! \\
    \vspace{1em}
    Haben Sie Fragen?
\end{frame}

\end{document}
